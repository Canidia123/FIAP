# -*- coding: utf-8 -*-
"""Tech_Challenge4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gP_NaZEXnrt86JBzJ5k_2z3d9eOKVUq7
"""

import pandas as pd

df_excel = pd.read_excel("Brent.xlsx")

df_excel.head()

df_excel.tail()

df_excel.shape

df_excel.info()

df_excel.describe()



df_excel.describe().T

def categorizar_petroleo(preço):
  if preço >76.80 : return "Caro"
  elif preço > 48.93 : return "Justo"
  else: return "Barato"

df_excel["Categoria_Brent"] = df_excel["Preço - petróleo bruto - Brent (FOB)"].apply(categorizar_petroleo)

df_excel.head()

df_excel.tail()

# Agrupar os dados pela coluna 'Categoria_Brent' e, em seguida, aplicar o describe()
df_grouped = df_excel.groupby("Categoria_Brent").describe()

# Exibir o resultado
print(df_grouped)

import numpy as np
import matplotlib.pyplot as plt

df_excel.head()

df_excel.info()

plt.plot(df_excel["Data"], df_excel["Preço - petróleo bruto - Brent (FOB)"])
plt.xlabel("Data")
plt.ylabel("Preço")
plt.title("Preço do Petróleo Brent")
plt.show()

! pip install scikit-learn

df_excel.head()

from sklearn.model_selection import train_test_split

x=df_excel["Data"]
y=df_excel["Preço - petróleo bruto - Brent (FOB)"]

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)

from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier(n_neighbors=3)

print(x_train.shape)
print(y_train.shape)

print("Primeiro Dia"), df_excel["Data"].min()

print("Último Dia"), df_excel["Data"].max()

import seaborn as sns

sns.set(style="whitegrid")
fig, axes = plt.subplots(figsize=(12, 6))
sns.boxplot (x="Preço - petróleo bruto - Brent (FOB)" , data = df_excel)
axes.set_title("Boxplot")
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

df_excel.head()

!pip install pmdarima

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error

# Carregar os dados
df = pd.read_excel("Brent.xlsx", parse_dates=['Data'], index_col='Data')

model = ARIMA(df['Preço - petróleo bruto - Brent (FOB)'], order=(5, 1, 0))  # ARIMA(p, d, q)
model_fit = model.fit()

forecast = model_fit.forecast(steps=15000)

plt.figure(figsize=(10,6))
plt.plot(df.index, df['Preço - petróleo bruto - Brent (FOB)'], label='Preços Dólar')
plt.plot(pd.date_range(df.index[-1], periods=15000, freq='D'), forecast, label='Previsões', color='red')
plt.legend()
plt.show()

from statsmodels.tsa.stattools import adfuller

# Teste ADF para verificar estacionaridade
result = adfuller(df['Preço - petróleo bruto - Brent (FOB)'])
print(f"ADF Statistic: {result[0]}")
print(f"p-value: {result[1]}")

# Diferenciação para tornar a série estacionária
df['preco_diff'] = df['Preço - petróleo bruto - Brent (FOB)'].diff().dropna()

plt.figure(figsize=(10,6))
plt.plot(df.index, df['Preço - petróleo bruto - Brent (FOB)'], label='Preços Dólar')
plt.plot(pd.date_range(df.index[-1], periods=15000, freq='D'), forecast, label='Previsões', color='red')
plt.legend()
plt.show()

from statsmodels.tsa.statespace.sarimax import SARIMAX

# Ajuste de SARIMA (p, d, q) x (P, D, Q, m)
model = SARIMAX(df['Preço - petróleo bruto - Brent (FOB)'], order=(5, 1, 0), seasonal_order=(1, 1, 1, 12))  # Usando sazonalidade de 12 meses
model_fit = model.fit()

# Fazer previsões
forecast = model_fit.forecast(steps=15000)

# Visualizar os resultados
plt.figure(figsize=(10,6))
plt.plot(df.index, df['Preço - petróleo bruto - Brent (FOB)'], label='Preço Dólar')
plt.plot(pd.date_range(df.index[-1], periods=15000, freq='D'), forecast, label='Previsões', color='red')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.model_selection import train_test_split

# Carregar os dados de preço do petróleo
df = pd.read_excel('Brent.xlsx', parse_dates=['Data'], index_col='Data')

# Verificar se há dados ausentes
df.isnull().sum()

# Preenchendo dados ausentes com o valor anterior
df = df.fillna(method='ffill')

# Vamos usar apenas a coluna 'preco' para previsão
data = df['Preço - petróleo bruto - Brent (FOB)'].values

# Normalizar os dados para valores entre 0 e 1
scaler = MinMaxScaler(feature_range=(0, 1))
data_scaled = scaler.fit_transform(data.reshape(-1, 1))

# Função para criar dados de entrada e saída para LSTM
def create_dataset(data, time_step=30):
    X, y = [], []
    for i in range(len(data)-time_step-1):
        X.append(data[i:(i+time_step), 0])  # Preços anteriores
        y.append(data[i + time_step, 0])  # Preço futuro
    return np.array(X), np.array(y)

# Criar datasets de treino e teste
time_step = 30  # Vamos usar 30 dias anteriores para prever o próximo
X, y = create_dataset(data_scaled, time_step)

# Dividir os dados em treino e teste (80% treino e 20% teste)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Reshape dos dados para o formato [amostras, time_step, 1]
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

# Construir o modelo LSTM
model = Sequential()

# Camada LSTM
model.add(LSTM(units=50, return_sequences=False, input_shape=(X_train.shape[1], 1)))

# Camada densa de saída
model.add(Dense(units=1))

# Compilar o modelo
model.compile(optimizer='adam', loss='mean_squared_error')

# Treinar o modelo
model.fit(X_train, y_train, epochs=10, batch_size=32, verbose=1)

# Fazer previsões no conjunto de teste
predictions = model.predict(X_test)

# Inverter a normalização dos dados para obter os preços reais
predictions = scaler.inverse_transform(predictions)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

# Visualizar as previsões
plt.figure(figsize=(10, 6))
plt.plot(y_test_actual, color='blue', label='Preço Dolar')
plt.plot(predictions, color='red', label='Previsão')
plt.title('Previsão do Preço do Petróleo com LSTM')
plt.xlabel('Data')
plt.ylabel('Preço do Petróleo (USD)')
plt.legend()
plt.show()

# Avaliar a performance do modelo
from sklearn.metrics import mean_absolute_error
mae = mean_absolute_error(y_test_actual, predictions)
print(f'Erro Absoluto Médio (MAE): {mae}')

